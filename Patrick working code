#include <Adafruit_NeoPixel.h>
#define BUTTON_PIN 2
#define PIXEL_PIN 6
#define PIXEL_COUNT  100
int yellow_block[] = {98, 99, 93, 94, 255, 255, 0, 12, 1};
int purple_T[] = {99, 98, 97, 93, 128, 0, 128, 22, 2};
int blue_L[] = {97, 92, 93, 94, 0, 0, 255, 4, 3};
int orange_L[] = { 92, 93, 94, 99, 255, 165, 0, 8, 4};
int green_Z[] = { 92, 93, 98, 99, 0, 255, 0, 16, 5};
int red_Z[] = {97, 98, 93, 94, 255, 0, 0, 24, 6};
int cyan_stick[] = {96, 97, 98, 99, 0, 255, 255, 0, 7};
int box[9];
int game_board[20][5];
int r;
int g;
int b;
int score;
bool oldbuttonState;
const int xPin = A0;
const int yPin = A1;
int xAxis, yAxis;
bool oldState;
bool tracker;
float time_played = 0;
bool winner;
Adafruit_NeoPixel pixels = Adafruit_NeoPixel(PIXEL_COUNT, PIXEL_PIN, NEO_GRB + NEO_KHZ800);

int showType = 0;
void setup() {
  pinMode(9, INPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  pixels.begin();
  pixels.show();
  score = 0;
  for (int i = 0; i < 20; i++) {
    for (int j = 0; j < 5; j++) {
      game_board[i][j] = 0;
    }
  }
  oldbuttonState = HIGH;
  Serial.begin(9600);
}

void loop() {
  button_push();
}

void button_push() {
  int buttonState = digitalRead(9);
  if (buttonState == LOW && oldbuttonState == HIGH)
  {
    oldbuttonState = LOW;
    game_play();
  }
  if (buttonState == HIGH) {
    oldbuttonState = HIGH;
  }
}

void game_play() {
  winner = true;
  bool exit_ = true;
  while (score < 30 && exit_) {
    random_drop();
    for (int j = 0; j < 5; j++) {
      if (game_board[19][j] != 0) {
        you_lose();
        exit_ = false;
        break;
      }
    }
  }
  if (winner) {
    you_win();
  }
}

void you_win() {
  Serial.println("Congrats you won!!!!");
  Serial.print("Time Played: ");
  Serial.print(time_played);
  Serial.print(" |Score: ");
  Serial.println(score);
  theaterChaseRainbow(10);
  for (int i = 0; i < 20; i++) {
    for (int j = 0; j < 5; j++) {
      game_board[i][j] = 0;
    }
  }
  color_board();
  time_played = 0;
  score = 0;
}

void theaterChaseRainbow(uint8_t wait) {
  for (int j=0; j < 256; j++) {     // cycle all 256 colors in the wheel
    for (int q=0; q < 3; q++) {
      for (int i=0; i < pixels.numPixels(); i=i+3) {
        pixels.setPixelColor(i+q, Wheel( (i+j) % 255));    //turn every third pixel on
      }
      pixels.show();

      delay(wait);

      for (int i=0; i < pixels.numPixels(); i=i+3) {
        pixels.setPixelColor(i+q, 0);        //turn every third pixel off
      }
    }
  }
}

uint32_t Wheel(byte WheelPos) {
  WheelPos = 255 - WheelPos;
  if(WheelPos < 85) {
    return pixels.Color(255 - WheelPos * 3, 0, WheelPos * 3);
  }
  if(WheelPos < 170) {
    WheelPos -= 85;
    return pixels.Color(0, WheelPos * 3, 255 - WheelPos * 3);
  }
  WheelPos -= 170;
  return pixels.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
}

void you_lose() {
  Serial.println("Sorry, You Lost. Try Again");
  Serial.print("Time Played: ");
  Serial.print(time_played);
  Serial.print(" |Score: ");
  Serial.println(score);
  delay(4000);
  winner = false;
  for (int i = 0; i < 20; i++) {
    for (int j = 0; j < 5; j++) {
      game_board[i][j] = 0;
    }
  }
  color_board();
  time_played = 0;
  score = 0;
}

void color_board() {
  for (int i = 0; i < 20; i++) {
    for (int j = 0; j < 5; j++) {
      if (game_board[i][j] == 0) {
        r = 0;
        g = 0;
        b = 0;
      }
      else if (game_board[i][j] == 1) {      // yellow
        r = 255;
        g = 255;
        b = 0;
      }
      else if (game_board[i][j] == 2) {      // purple
        r = 128;
        g = 0;
        b = 128;
      }
      else if (game_board[i][j] == 3) {      // blue
        r = 0;
        g = 0;
        b = 255;
      }
      else if (game_board[i][j] == 4) {      // orange
        r = 255;
        g = 165;
        b = 0;
      }
      else if (game_board[i][j] == 5) {      // green
        r = 0;
        g = 255;
        b = 0;
      }
      else if (game_board[i][j] == 6) {      // red
        r = 255;
        g = 0;
        b = 0;
      }
      else if (game_board[i][j] == 7) {     // cyan
        r = 0;
        g = 255;
        b = 255;
      }
      int pos = 5 * i + j;
      pixels.setPixelColor(pos, pixels.Color(r, g, b));
    }
  }
  pixels.show();
}

void random_drop() {
  int rn = random(1, 8);
  switch (rn) {
    case 1:
      for (int i = 0; i < 9; i++) {
        box[i] = yellow_block[i];
      }
      break;
    case 2:
      for (int i = 0; i < 9; i++) {
        box[i] = purple_T[i];
      }
      break;
    case 3:
      for (int i = 0; i < 9; i++) {
        box[i] = blue_L[i];
      }
      break;
    case 4:
      for (int i = 0; i < 9; i++) {
        box[i] = orange_L[i];
      }
      break;
    case 5:
      for (int i = 0; i < 9; i++) {
        box[i] = green_Z[i];
      }
      break;
    case 6:
      for (int i = 0; i < 9; i++) {
        box[i] = red_Z[i];
      }
      break;
    case 7:
      for (int i = 0; i < 9; i++) {
        box[i] = cyan_stick[i];
      }
      break;
  }
  drop_shape();
}

void drop_shape() {
  tracker = true;
  while (tracker) {
    for (int i = 0; i < 4; i++) {
      pixels.setPixelColor(box[i], pixels.Color(box[4], box[5], box[6]));
    }
    pixels.show();
    drop_delay();
    if (!tracker) {
      break;
    }
    for (int i = 0; i < 4; i++) {
      pixels.setPixelColor(box[i], pixels.Color(0, 0, 0));
    }
    pixels.show();
    drop_pixels();
  }
  add_to_gameboard();
  row_check();
}

void drop_delay() {
  for (int i = 0; i <= 10; i++) {
    delay(50);
    time_played += 0.05;
    xAxis = analogRead(xPin);
    yAxis = analogRead(yPin);
    int buttonState = digitalRead(2);
    if (buttonState == HIGH) {
      oldbuttonState = HIGH;
    }
    if (xAxis < 650 && yAxis < 650 && yAxis > 350) {
      oldState = LOW;
    }
    if (xAxis > 650 && oldState == LOW) {
      rotate_shape();
      oldState = HIGH;
    }
    if (yAxis > 650 && oldState == LOW) {
      move_sideways(1);
      oldState = HIGH;
    }
    if (yAxis < 350 && oldState == LOW) {
      move_sideways(-1);
      oldState = HIGH;
    }
    if (buttonState == LOW && oldbuttonState == HIGH)
    {
      drop_to_bottom();
      oldbuttonState = LOW;
      tracker = false;
      break;
    }
    test_stacker();
    for (int i = 0; i < 4; i++) {
      if (box[i] / 5 == 0) {
        tracker = false;
        break;
      }
    }
    if (!tracker) {
      break;
    }
  }
}

void add_to_gameboard() {
  int r;
  int c;
  for (int i = 0; i < 4; i++) {
    r = box[i] / 5;
    c = box[i] % 5;
    game_board[r][c] = box[8];
  }
  color_board();
}

void test_stacker() {
  for (int i = 0; i < 20; i++) {
    for (int j = 0; j < 5; j++) {
      if (game_board[i][j] != 0) {
        for (int k = 0; k < 4; k++) {
          if ((box[k] / 5 - i) == 1 && box[k] % 5 == j) {
            tracker = false;
          }
        }
      }
    }
  }
}

void row_check() {
  for (int r = 19; r > -1; r--) {
    if (game_board[r][0] != 0 && game_board[r][1] != 0 && game_board[r][2] != 0 && game_board[r][3] != 0 && game_board[r][4] != 0) {
      clear_row(r);
      score++;
    }
  }
  color_board();
}

void clear_row(int row) {
  for (int r = row; r < 20; r++) {
    for (int c = 0; c < 5; c++) {
      if (r != 19) {
        game_board[r][c] = game_board[r + 1][c];
      }
      else {
        game_board[r][c] = 0;
      }
    }
  }
}

void move_sideways(int p) {
  bool possible = HIGH;
  for (int i = 0; i < 4; i++) {
    if (box[i] % 5 == 0 && p == -1) {
      possible = LOW;
      break;
    }
    if (box[i] % 5 == 4 && p == 1) {
      possible = LOW;
      break;
    }
  }
  if (possible == HIGH) {
    for (int i = 0; i < 4; i++) {
      pixels.setPixelColor(box[i], pixels.Color(0, 0, 0));
    }
    pixels.show();
    for (int i = 0; i < 4; i++) {
      box[i] = box[i] + p;
    }
    for (int i = 0; i < 4; i++) {
      pixels.setPixelColor(box[i], pixels.Color(box[4], box[5], box[6]));
    }
    pixels.show();
  }
}

void drop_pixels() {
  for (int i = 0; i < 4; i++) {
    box[i] = box[i] - 5;
  }
}

void drop_to_bottom() {
  int row_to_bottom ;
  row_to_bottom = box[0] / 5;
  for (int i = 1; i < 4; i++) {
    if ((box[i] / 5) < row_to_bottom) {
      row_to_bottom = (box[i] / 5);
    }
  }
  for (int r = 0; r < 20; r++) {
    for (int c = 0; c < 5; c++) {
      if (game_board[r][c] != 0) {
        for (int i = 0; i < 4; i++) {
          if (box[i] % 5 == c && row_to_bottom > ((box[i] / 5) - r - 1)) {
            row_to_bottom = (box[i] / 5) - r - 1;
          }
        }
      }
    }
  }
  for (int i = 0; i < 4; i++) {
    pixels.setPixelColor(box[i], pixels.Color(0, 0, 0));
  }
  pixels.show();
  for (int i = 0; i < row_to_bottom ; i++) {
    drop_pixels();
  }
  for (int i = 0; i < 4; i++) {
    pixels.setPixelColor(box[i], pixels.Color(box[4], box[5], box[6]));
  }
  pixels.show();
}

void rotate_shape() {
  int c1;
  int c2;
  int c3;
  int c4;
  bool allow_turn = true;
  int copy_box[4];
  for (int i = 0; i < 4; i++) {
    copy_box[i] = box[i];
  }
  switch (box[7]) {
    case 0:
      c1 = 7;
      c2 = 1;
      c3 = -5;
      c4 = -11;
      break;
    case 1:
      c1 = -9;
      c2 = -5;
      c3 = -1;
      c4 = 3;
      break;
    case 2:
      c1 = -7;
      c2 = -1;
      c3 = 5;
      c4 = 11;
      break;
    case 3:
      c1 = 9;
      c2 = 5;
      c3 = 1;
      c4 = -3;
      break;
    case 4:
      c1 = 2;
      c2 = 6;
      c3 = 0;
      c4 = -6;
      break;
    case 5:
      c1 = -10;
      c2 = -4;
      c3 = 0;
      c4 = 4;
      break;
    case 6:
      c1 = -2;
      c2 = -6;
      c3 = 0;
      c4 = 6;
      break;
    case 7:
      c1 = 10;
      c2 = 4;
      c3 = 0;
      c4 = -4;
      break;
    case 8:
      c1 = 6;
      c2 = 0;
      c3 = -6;
      c4 = -10;
      break;
    case 9:
      c1 = -4;
      c2 = 0;
      c3 = 4;
      c4 = -2;
      break;
    case 10:
      c1 = -6;
      c2 = 0;
      c3 = 6;
      c4 = 10;
      break;
    case 11:
      c1 = 4;
      c2 = 0;
      c3 = -4;
      c4 = 2;
      break;
    case 12:
      c1 = 0;
      c2 = 0;
      c3 = 0;
      c4 = 0;
      break;
    case 13:
      c1 = 0;
      c2 = 0;
      c3 = 0;
      c4 = 0;
      break;
    case 14:
      c1 = 0;
      c2 = 0;
      c3 = 0;
      c4 = 0;
      break;
    case 15:
      c1 = 0;
      c2 = 0;
      c3 = 0;
      c4 = 0;
      break;
    case 16:
      c1 = 6;
      c2 = 0;
      c3 = -4;
      c4 = -10;
      break;
    case 17:
      c1 = -4;
      c2 = 0;
      c3 = -6;
      c4 = -2;
      break;
    case 18:
      c1 = -6;
      c2 = 0;
      c3 = 4;
      c4 = 10;
      break;
    case 19:
      c1 = 4;
      c2 = 0;
      c3 = 6;
      c4 = 2;
      break;
    case 20:
      c1 = 6;
      c2 = 0;
      c3 = -6;
      c4 = -4;
      break;
    case 21:
      c1 = -4;
      c2 = 0;
      c3 = 4;
      c4 = -6;
      break;
    case 22:
      c1 = -6;
      c2 = 0;
      c3 = 6;
      c4 = 4;
      break;
    case 23:
      c1 = 4;
      c2 = 0;
      c3 = -4;
      c4 = 6;
      break;
    case 24:
      c1 = 2;
      c2 = -4;
      c3 = 0;
      c4 = -6;
      break;
    case 25:
      c1 = -10;
      c2 = -6;
      c3 = 0;
      c4 = 4;
      break;
    case 26:
      c1 = -2;
      c2 = 4;
      c3 = 0;
      c4 = 6;
      break;
    case 27:
      c1 = 10;
      c2 = 6;
      c3 = 0;
      c4 = -4;
      break;
  }
  copy_box[0] = box[0] + c1;
  copy_box[1] = box[1] + c2;
  copy_box[2] = box[2] + c3;
  copy_box[3] = box[3] + c4;
  for (int i = 0; i < 20; i++) {
    for (int j = 0; j < 5; j++) {
      for (int k = 0; k < 4; k++) {
        if (game_board[i][j] != 0 && copy_box[k] / 5 == i && copy_box[k] % 5 == j) {
          allow_turn = false;
          break;
        }
      }
    }
  }
  for (int i = 0; i < 4; i++) {
    if (copy_box[i] > 99) {
      allow_turn = false;
      break;
    }
  }
  int connected_count_1 = 0;
  int connected_count_2 = 0;

  for (int i = 0; i < 4; i++) {
    if ((box[i] / 5 == box[i + 1] / 5 && box[i + 1] % 5 - box[i] % 5 == 1)) {
      connected_count_1++;
    }
    if ((box[i] / 5 == box[i + 1] / 5 && box[i] % 5 - box[i + 1] % 5 == 1)) {
      connected_count_1++;
    }
    if ((box[i] % 5 == box[i + 1] % 5 && box[i] / 5 - box[i + 1] / 5 == 1)) {
      connected_count_1++;
    }
    if ((box[i] % 5 == box[i + 1] % 5 && box[i + 1] / 5 - box[i] / 5 == 1)) {
      connected_count_1++;
    }
  }
  for (int i = 0; i < 3; i++) {
    if ((copy_box[i] / 5 == copy_box[i + 1] / 5 && copy_box[i + 1] % 5 - copy_box[i] % 5 == 1)) {
      connected_count_2++;
    }
    if ((copy_box[i] / 5 == copy_box[i + 1] / 5 && copy_box[i] % 5 - copy_box[i + 1] % 5 == 1)) {
      connected_count_2++;
    }
    if ((copy_box[i] % 5 == copy_box[i + 1] % 5 && copy_box[i] / 5 - copy_box[i + 1] / 5 == 1)) {
      connected_count_2++;
    }
    if ((copy_box[i] % 5 == copy_box[i + 1] % 5 && copy_box[i + 1] / 5 - copy_box[i] / 5 == 1)) {
      connected_count_2++;
    }
  }
  for (int i = 1; i < 4; i++) {
    if ((box[i] / 5 == box[i - 1] / 5 && box[i - 1] % 5 - box[i] % 5 == 1)) {
      connected_count_1++;
    }
    if ((box[i] / 5 == box[i - 1] / 5 && box[i] % 5 - box[i - 1] % 5 == 1)) {
      connected_count_1++;
    }
    if ((box[i] % 5 == box[i - 1] % 5 && box[i] / 5 - box[i - 1] / 5 == 1)) {
      connected_count_1++;
    }
    if ((box[i] % 5 == box[i - 1] % 5 && box[i - 1] / 5 - box[i] / 5 == 1)) {
      connected_count_1++;
    }
  }
  for (int i = 1; i < 4; i++) {
    if ((copy_box[i] / 5 == copy_box[i - 1] / 5 && copy_box[i - 1] % 5 - copy_box[i] % 5 == 1)) {
      connected_count_2++;
    }
    if ((copy_box[i] / 5 == copy_box[i - 1] / 5 && copy_box[i] % 5 - copy_box[i - 1] % 5 == 1)) {
      connected_count_2++;
    }
    if ((copy_box[i] % 5 == copy_box[i - 1] % 5 && copy_box[i] / 5 - copy_box[i - 1] / 5 == 1)) {
      connected_count_2++;
    }
    if ((copy_box[i] % 5 == copy_box[i - 1] % 5 && copy_box[i - 1] / 5 - copy_box[i] / 5 == 1)) {
      connected_count_2++;
    }
  }

  if (connected_count_1 != connected_count_2) {
    allow_turn = false;
  }

  if (allow_turn) {
    if (box[7] % 4 == 3) {
      box[7] = box[7] - 3;
    }
    else {
      box[7]++;
    }
    for (int i = 0; i < 4; i++) {
      pixels.setPixelColor(box[i], pixels.Color(0, 0, 0));
    }
    pixels.show();
    for (int i = 0; i < 4; i++) {
      pixels.setPixelColor(copy_box[i], pixels.Color(box[4], box[5], box[6]));
    }
    pixels.show();
    for (int i = 0; i < 4; i++) {
      box[i] = copy_box[i];

    }
  }
}
